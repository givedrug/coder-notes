# （LeetCode练习题）二分查找


**题目**
- LeetCode 33. Search in Rotated Sorted Array 搜索旋转排序数组
- LeetCode 34. Find First and Last Position of Element in Sorted Array 在排序数组中查找元素的第一个和最后一个位置
- LeetCode 50. Pow(x, n) Pow(x, n)
- LeetCode 69. Sqrt(x) x 的平方根
- LeetCode 153. Find Minimum in Rotated Sorted Array 寻找旋转排序数组中的最小值
- LeetCode 162. Find Peak Element 寻找峰值
- LeetCode 278. First Bad Version 第一个错误的版本
- LeetCode 367. Valid Perfect Square 有效的完全平方数
- LeetCode 374. Guess Number Higher or Lower 猜数字大小
- LeetCode 658. Find K Closest Elements 找到 K 个最接近的元素
- LeetCode 702. Search in a Sorted Array of Unknown Size 搜索长度未知的有序数组
- LeetCode 704. Binary Search 二分查找
- LeetCode 744. Find Smallest Letter Greater Than Target 寻找比目标字母大的最小字母
- （困难）LeetCode 4. Median of Two Sorted Arrays 寻找两个正序数组的中位数
- （困难）LeetCode 154. Find Minimum in Rotated Sorted Array II 寻找旋转排序数组中的最小值 II
- （困难）LeetCode 410. Split Array Largest Sum 分割数组的最大值
- （困难）LeetCode 719. Find K-th Smallest Pair Distance 找出第 K 小的数对距离

**思路**

LeetCode 33. Search in Rotated Sorted Array 搜索旋转排序数组

```
方法一：使用二分法，先找到最小数字索引，然后根据target值和nums边界的大小关系，再使用二分查找找到target
复杂度：log(n)

方法二：官方解答中，可以使用一次二分查找解决，与仅对比中间值与目标值不同，此时需要对比左右边界、中间值与目标值的关系（必然有一侧是严格有序的）来确定二分走向，而且还要小心临近目标时的处理
复杂度：log(n)
```

LeetCode 34. Find First and Last Position of Element in Sorted Array 在排序数组中查找元素的第一个和最后一个位置

```
方法一：先通过二分找到一个符合的值，然后用二分分别找到左右边界
复杂度：log(n)

方法二：其实也可以直接分两次找到左右边界，而不用非要先找到一个符合的值
复杂度：log(n)
```

LeetCode 50. Pow(x, n) Pow(x, n)

```
将n转为二进制，并保存中间结果x^1、x^2、x^4、x^8、x^16……，然后计算n的二进制为1的位对应的中间结果的乘积（如果n为负数则使用除法）。
备注：需要注意Integer.MIN_VALUE的特殊处理
复杂度：log(n)
```

LeetCode 69. Sqrt(x) x 的平方根

```
方法一：二分法。由均值不等式，x和1的算术平均数一定大于几何平均数，可以从1到(x+1)/2为左右边界
复杂度：log(n)

方法二：官方解答中，还可以使用牛顿迭代法求解
复杂度：log(n)
```

LeetCode 153. Find Minimum in Rotated Sorted Array 寻找旋转排序数组中的最小值

```
如果最左小于最右，说明没有经过翻转，直接返回第一个元素；其他情况通过二分查找找到突变处，返回右侧值即可
复杂度：log(n)
```

LeetCode 162. Find Peak Element 寻找峰值

```
特殊情况：
如果0元素比1元素大或者length-1元素比length-2元素大，则直接返回结果。
一般情况：
对于整体增减性，必然有0处为增，length-1处为减（因为左右边界都为负无穷大）。
对于中间值，则分为三种情况，如果中间值符合峰值，直接返回，如果中间值右侧增减性为增，则右边必有峰值，如果中间值右侧增减性为减，则左边必有峰值。
如此反复，必能找到峰值，且任何情况下，左右边界的增减性都是相反的。
复杂度：log(n)
```

LeetCode 278. First Bad Version 第一个错误的版本

```
二分法
复杂度：log(n)
```

LeetCode 367. Valid Perfect Square 有效的完全平方数

```
通过幂函数找到左右边界，然后二分确定是否为完全平方数
复杂度：log(n)
```

LeetCode 374. Guess Number Higher or Lower 猜数字大小

```
二分法
复杂度：log(n)
```

LeetCode 658. Find K Closest Elements 找到 K 个最接近的元素

```
先找到与x最接近的数（只需要找到大于等于x以及小于x的左右位置就可以了，因为最近接x的值不是左边就是右边），然后找到k个最接近的数
复杂度：log(n)+k
```

LeetCode 702. Search in a Sorted Array of Unknown Size 搜索长度未知的有序数组

```
先通过幂函数2^n确定粗略边界，然后二分查找
复杂度：log(n)
```

LeetCode 704. Binary Search 二分查找

```
二分法
复杂度：log(n)
```

LeetCode 744. Find Smallest Letter Greater Than Target 寻找比目标字母大的最小字母

```
二分法
复杂度：log(n)
```

（困难）LeetCode 4. Median of Two Sorted Arrays 寻找两个正序数组的中位数

```
方法一：一个最简单的方法就是合并之后（也可以不合并，而在两个数组上分别使用一个指针并计数）找到中间位置
复杂度：m+n

方法二：官方解答中，提供一种算法：
根据中位数定义，如果m+n为奇数，中位数就是合并排序之后第(m+n)/2的元素，如果m+n为偶数，中位数就是第(m+n)/2和第(m+n)/2+1的平均数。
因此查找中位数的操作，就变成了找到第(m+n)/2或第(m+n)/2+1的数的过程，即找到第k小的数。
维护两个指针，A与B数组，比较A与B数组第k/2的位置，则分为两种情况：
如果A的第k/2的数字小于B的第k/2的数字，则可以去掉A的这k/2个数，因为他们中一定没有第k小的数。反之去掉B的。
然后更新k（减掉k/2），直到k为1或一个数组变空，就找到了中位数。
复杂度：log(m+n)

方法三：官方解答中，还提供一种log(min(m,n))的算法（详细证明请参考官方解答）：
直接在较短的数组A上面二分查找，假设下标为i，并找到较长数组B的下表为j=(m+n+1)/2-i的数字，然后比较A[i-1]<=B[j]中i最大的位置，即为所得。
复杂度：log(min(m,n))
```

（困难）LeetCode 154. Find Minimum in Rotated Sorted Array II 寻找旋转排序数组中的最小值 II

```
方法一：使用二分法。
首先，如果尾元素大于头元素，则返回头；
如果左中右都相等，不能判断最小值在哪边，需要两边同时递归，除此之外，如果中间大于等于左边，则查找右边，如果中间小于等于右边，则查找左边。
复杂度：log(n)

方法二：官方题解中提到一种方法，可以不用递归，只比较中间与右侧：
当中间大于右侧时，左侧等于中间加一，因为中间一定不是；
当中间小于右侧时，右侧等于中间，因为中间有可能是；
当中间与右侧相等时，可以让右侧元素减一，因为既然相等，那么可以去掉一个重复值。
复杂度：log(n)
```

（困难）LeetCode 410. Split Array Largest Sum 分割数组的最大值

```
方法一：本题可以使用动态规划来实现，但需要求出所有子数组在不同分割情况下的最小最大和，因此效率较低。
复杂度：(n^2)*m，m是分成的非空的连续子数组的个数。

方法二：官方解答，还有一种基于二分查找的方案，复杂度更低。
注意到，所有子数组的和的取值范围在max(nums[])到sum(nums[])之间，可以对这个和进行二分查找，找到一个最小值x：
当大于等于x时，数组存在至少一个分割方案，满足所有的子数组和都小于等于x
当小于x时，数组不存在一种分割方案，满足所有的子数组和都小于等于x
于是，问题进一步转变为，给定一个x，判断是否至少存在一个分割方案的问题，这时可以使用贪心法来计算
从左到右遍历数组，并计算累加和，如果和超过x，则count加一，然后重新累加
直到count大于k（失败，即不存在），或者数组遍历完为止，count依旧小于等于k（成功，即存在）。
复杂度：n*log(m)，其中m=max(nums[])-sum(nums[])

备注：最开始的时候，我想到一种通过比例来切割的方案：
比如说，要分成3份，那么我先按1:2来分割数组，找到左右两边比例最接近1:2的分割方案（同时计算2:1的方案，左右都要考虑）。
然后记录"1"的和，以及继续将"2"的部分按1:1分割，这样就可以直接得出最终结果，甚至最优切割方案。
但是，局部最优解不一定是整体最优解，考虑这样一个反例：
[100,1,101,99]，k=3的分割方案
找到1:2的分界点：
从左到右100/(1+101+99)=0.497512438(相差0.002487562)，101/(101+99)=0.505(相差0.005)
从右向左99/(100+1+101)=0.49009901(相差0.00990099)，显然应该分割成[100],[1,101,99]
继续[1,101,99]，k=2的分割方案
找到1:1的分界点：[1,101],[99]最符合
最终[100,1,101,99]分割为[100],[1,101],[99]，最大和为102
但显然分割为[100,1],[101],[99]，最大和为101是最优分割方案。
所以按比例分割虽然局部考虑是最优分割方案，但不能保证是全局最优方案。
```

（困难）LeetCode 719. Find K-th Smallest Pair Distance 找出第 K 小的数对距离

```
如果暴力找到所有数字对之间的距离，然后排序，复杂度会非常高，指数级别。
参考官方题解，这是一个可以使用二分查找+二分查找（或双指针）的问题。
首先对数组进行排序，这样所有的距离都会落入[0,最大值-最小值]的范围内，对距离进行二分left=0，right=最大值-最小值，mid=(left+right)/2
然后，查找小于等于mid的距离有多少对，如果count>=k，则right=mid-1，否则，left=mid+1，当left>right时，停止，返回left即为所求的距离值。
对于查找"小于等于mid的距离有多少对"，可以有三种处理方式，但都需要对数字对的一端进行全遍历，下面以对右边数字进行遍历为例说明：
1）使用二分，对于某一个右边元素j，通过二分找到等于或大于mid-j的左边元素i，则j-i为当右边元素为j时，所有满足条件的数字对数
2）使用双指针，因为右边元素j不断变大，所以左边元素也一定不断变大才能满足条件，因此滑动左边元素即可，同样也是j-i对
3）结合二分与双指针，下一次左元素的起点不再从0开始，而是从上一次的左元素位置开始，这样可以减少二分查找的范围，进一步提升性能
复杂度：n为数组长度，D为最大值-最小值
1）O(n*log(n)*log(D))：外层log(D)，内层n*log(n)（遍历为n，二分为log(n)）
2）O(n*(log(n)+log(D)))：排序复杂度n*log(n)，外层log(D)，内层n
3）小于1和2
```
